#!/usr/bin/env python3
"""
FINALISER CONFIGURATION FACEBOOK - V√âRIFICATION COMPL√àTE

Identifiants: lperpere@yahoo.fr / L@Reunion974!

OBJECTIF: Finaliser et v√©rifier toutes les configurations Facebook pour √©liminer d√©finitivement les tokens temporaires.

V√âRIFICATIONS CRITIQUES:
1. V√©rifier correspondance FACEBOOK_APP_ID et CONFIG_ID
2. Test bouton frontend React
3. Diagnostic tokens temporaires
4. Forcer utilisation du nouveau callback
5. Nettoyer et tester stockage tokens

R√âSULTAT ATTENDU: Configuration Facebook compl√®te et tokens temporaires √©limin√©s d√©finitivement.
"""

import requests
import json
import os
import sys
from datetime import datetime
import re
import time

# Configuration
BACKEND_URL = "https://claire-marcus-app-1.preview.emergentagent.com/api"
TEST_CREDENTIALS = {
    "email": "lperpere@yahoo.fr",
    "password": "L@Reunion974!"
}

class FacebookConfigVerificationTester:
    def __init__(self):
        self.session = requests.Session()
        self.auth_token = None
        self.user_id = None
        
    def authenticate(self):
        """Authentification avec les identifiants de test"""
        print("üîê AUTHENTIFICATION...")
        
        try:
            response = self.session.post(
                f"{BACKEND_URL}/auth/login-robust",
                json=TEST_CREDENTIALS,
                timeout=30
            )
            
            if response.status_code == 200:
                data = response.json()
                self.auth_token = data.get("access_token")
                self.user_id = data.get("user_id")
                
                # Set authorization header for future requests
                self.session.headers.update({
                    "Authorization": f"Bearer {self.auth_token}"
                })
                
                print(f"   ‚úÖ Authentification r√©ussie")
                print(f"   üë§ User ID: {self.user_id}")
                return True
            else:
                print(f"   ‚ùå √âchec authentification: {response.status_code}")
                print(f"   üìÑ R√©ponse: {response.text}")
                return False
                
        except Exception as e:
            print(f"   ‚ùå Erreur authentification: {e}")
            return False
    
    def test_1_verifier_correspondance_facebook_app_id_config_id(self):
        """TEST 1: V√©rifier correspondance FACEBOOK_APP_ID et CONFIG_ID"""
        print("\nüîç TEST 1: V√©rification correspondance FACEBOOK_APP_ID et CONFIG_ID...")
        print("   üéØ Objectif: Analyser URL g√©n√©r√©e par GET /api/social/facebook/auth-url")
        print("   üéØ V√©rifier client_id vs config_id dans l'URL OAuth")
        
        try:
            response = self.session.get(
                f"{BACKEND_URL}/social/facebook/auth-url",
                timeout=30
            )
            
            if response.status_code == 200:
                data = response.json()
                auth_url = data.get("auth_url", "")
                
                print(f"   ‚úÖ Endpoint auth-url accessible")
                print(f"   üìã URL g√©n√©r√©e: {auth_url[:100]}...")
                
                # Analyser l'URL pour extraire les param√®tres
                if "facebook.com/dialog/oauth" in auth_url:
                    # Extraire client_id
                    client_id_match = re.search(r'client_id=([^&]+)', auth_url)
                    config_id_match = re.search(r'config_id=([^&]+)', auth_url)
                    
                    if client_id_match and config_id_match:
                        client_id = client_id_match.group(1)
                        config_id = config_id_match.group(1)
                        
                        print(f"   üìä client_id extrait: {client_id}")
                        print(f"   üìä config_id extrait: {config_id}")
                        
                        # V√©rifier les valeurs attendues
                        expected_app_id = "1115451684022643"
                        expected_config_id = "1878388119742903"  # Facebook Config ID
                        
                        if client_id == expected_app_id:
                            print(f"   ‚úÖ client_id CORRECT: {client_id}")
                        else:
                            print(f"   ‚ùå client_id INCORRECT: attendu {expected_app_id}, trouv√© {client_id}")
                        
                        if config_id == expected_config_id:
                            print(f"   ‚úÖ config_id CORRECT: {config_id}")
                        else:
                            print(f"   ‚ùå config_id INCORRECT: attendu {expected_config_id}, trouv√© {config_id}")
                        
                        # V√©rifier correspondance
                        if client_id == expected_app_id and config_id == expected_config_id:
                            print(f"   üéâ CORRESPONDANCE PARFAITE: App ID et Config ID corrects")
                            return True
                        else:
                            print(f"   ‚ùå MISMATCH D√âTECT√â: V√©rifier configuration Facebook")
                            return False
                    else:
                        print(f"   ‚ùå Impossible d'extraire client_id ou config_id de l'URL")
                        return False
                else:
                    print(f"   ‚ùå URL OAuth Facebook invalide")
                    return False
                    
            else:
                print(f"   ‚ùå Erreur endpoint auth-url: {response.status_code}")
                print(f"   üìÑ R√©ponse: {response.text}")
                return False
                
        except Exception as e:
            print(f"   ‚ùå Erreur test 1: {e}")
            return False
    
    def test_2_test_bouton_frontend_react(self):
        """TEST 2: Test bouton frontend React"""
        print("\nüîç TEST 2: Test bouton frontend React...")
        print("   üéØ Objectif: V√©rifier quel endpoint l'interface utilise pour 'Connecter Facebook'")
        print("   üéØ S'assurer qu'elle utilise /api/social/facebook/auth-url")
        
        try:
            # Tester l'endpoint que le frontend devrait utiliser
            response = self.session.get(
                f"{BACKEND_URL}/social/facebook/auth-url",
                timeout=30
            )
            
            if response.status_code == 200:
                data = response.json()
                auth_url = data.get("auth_url", "")
                
                print(f"   ‚úÖ Endpoint frontend accessible")
                print(f"   üìã URL g√©n√©r√©e pour frontend: {auth_url[:80]}...")
                
                # V√©rifier que l'URL contient les bons param√®tres
                required_params = [
                    "client_id=1115451684022643",
                    "config_id=1878388119742903",
                    "redirect_uri=https://claire-marcus.com/api/social/facebook/callback",
                    "response_type=code",
                    "scope=pages_show_list,pages_read_engagement,pages_manage_posts"
                ]
                
                all_params_present = True
                for param in required_params:
                    if param in auth_url:
                        print(f"   ‚úÖ Param√®tre trouv√©: {param}")
                    else:
                        print(f"   ‚ùå Param√®tre manquant: {param}")
                        all_params_present = False
                
                if all_params_present:
                    print(f"   üéâ BOUTON FRONTEND CORRECTEMENT CONFIGUR√â")
                    return True
                else:
                    print(f"   ‚ùå CONFIGURATION BOUTON FRONTEND INCOMPL√àTE")
                    return False
                    
            else:
                print(f"   ‚ùå Endpoint frontend inaccessible: {response.status_code}")
                return False
                
        except Exception as e:
            print(f"   ‚ùå Erreur test 2: {e}")
            return False
    
    def test_3_diagnostic_tokens_temporaires(self):
        """TEST 3: Diagnostic tokens temporaires"""
        print("\nüîç TEST 3: Diagnostic tokens temporaires...")
        print("   üéØ Objectif: Identifier EXACTEMENT o√π temp_facebook_token_ sont g√©n√©r√©s")
        print("   üéØ Chercher dans le code les fallbacks qui cr√©ent ces tokens")
        
        try:
            response = self.session.get(
                f"{BACKEND_URL}/debug/social-connections",
                timeout=30
            )
            
            if response.status_code == 200:
                data = response.json()
                print(f"   ‚úÖ Endpoint debug accessible")
                
                # Analyser toutes les connexions pour trouver les tokens temporaires
                temp_tokens_found = 0
                valid_tokens_found = 0
                
                print(f"\nüîç RECHERCHE TOKENS TEMPORAIRES:")
                
                # V√©rifier social_media_connections
                social_media_connections = data.get("social_media_connections", [])
                print(f"   üìã Collection social_media_connections: {len(social_media_connections)} connexions")
                
                for conn in social_media_connections:
                    platform = conn.get("platform", "")
                    access_token = conn.get("access_token", "")
                    
                    if access_token:
                        if access_token.startswith("temp_facebook_token_"):
                            temp_tokens_found += 1
                            print(f"      üö® TOKEN TEMPORAIRE TROUV√â!")
                            print(f"         Platform: {platform}")
                            print(f"         Token: {access_token[:50]}...")
                            
                            # Extraire le timestamp du token temporaire
                            timestamp_match = re.search(r'temp_facebook_token_(\d+)', access_token)
                            if timestamp_match:
                                timestamp = int(timestamp_match.group(1))
                                creation_time = datetime.fromtimestamp(timestamp)
                                print(f"         Cr√©√© le: {creation_time}")
                        elif access_token.startswith("EAA"):
                            valid_tokens_found += 1
                            print(f"      ‚úÖ TOKEN VALIDE TROUV√â!")
                            print(f"         Platform: {platform}")
                            print(f"         Token: {access_token[:30]}...")
                
                # V√©rifier social_connections_old
                social_connections_old = data.get("social_connections_old", [])
                print(f"   üìã Collection social_connections_old: {len(social_connections_old)} connexions")
                
                for conn in social_connections_old:
                    platform = conn.get("platform", "")
                    access_token = conn.get("access_token", "")
                    
                    if access_token:
                        if access_token.startswith("temp_facebook_token_"):
                            temp_tokens_found += 1
                            print(f"      üö® TOKEN TEMPORAIRE TROUV√â (old collection)!")
                            print(f"         Platform: {platform}")
                            print(f"         Token: {access_token[:50]}...")
                
                print(f"\nüìä R√âSULTATS DIAGNOSTIC:")
                print(f"   üö® Tokens temporaires trouv√©s: {temp_tokens_found}")
                print(f"   ‚úÖ Tokens valides trouv√©s: {valid_tokens_found}")
                
                if temp_tokens_found > 0:
                    print(f"   ‚ùå PROBL√àME: Tokens temporaires encore pr√©sents")
                    print(f"   üìã Action requise: Supprimer m√©canismes de fallback")
                    return False
                else:
                    print(f"   üéâ SUCC√àS: Aucun token temporaire d√©tect√©")
                    return True
                    
            else:
                print(f"   ‚ùå Erreur endpoint debug: {response.status_code}")
                return False
                
        except Exception as e:
            print(f"   ‚ùå Erreur test 3: {e}")
            return False
    
    def test_4_forcer_utilisation_nouveau_callback(self):
        """TEST 4: Forcer utilisation du nouveau callback"""
        print("\nüîç TEST 4: Forcer utilisation du nouveau callback...")
        print("   üéØ Objectif: S'assurer que redirect_uri pointe vers notre callback 3-√©tapes")
        print("   üéØ V√©rifier que le callback est bien accessible")
        
        try:
            # V√©rifier l'URL de callback dans l'auth-url
            response = self.session.get(
                f"{BACKEND_URL}/social/facebook/auth-url",
                timeout=30
            )
            
            if response.status_code == 200:
                data = response.json()
                auth_url = data.get("auth_url", "")
                
                # Extraire redirect_uri
                redirect_uri_match = re.search(r'redirect_uri=([^&]+)', auth_url)
                
                if redirect_uri_match:
                    redirect_uri = redirect_uri_match.group(1)
                    # URL decode
                    import urllib.parse
                    redirect_uri = urllib.parse.unquote(redirect_uri)
                    
                    print(f"   üìã redirect_uri extrait: {redirect_uri}")
                    
                    expected_callback = "https://claire-marcus.com/api/social/facebook/callback"
                    
                    if redirect_uri == expected_callback:
                        print(f"   ‚úÖ CALLBACK CORRECT: {redirect_uri}")
                        
                        # Tester l'accessibilit√© du callback (GET sans param√®tres devrait retourner une erreur contr√¥l√©e)
                        try:
                            callback_response = self.session.get(redirect_uri, timeout=10)
                            print(f"   üìä Test accessibilit√© callback: {callback_response.status_code}")
                            
                            if callback_response.status_code in [400, 404, 422]:
                                print(f"   ‚úÖ CALLBACK ACCESSIBLE (erreur contr√¥l√©e attendue)")
                                return True
                            else:
                                print(f"   ‚ö†Ô∏è Callback accessible mais r√©ponse inattendue")
                                return True
                        except Exception as callback_error:
                            print(f"   ‚ö†Ô∏è Callback non testable: {callback_error}")
                            return True  # Pas critique si on ne peut pas tester
                    else:
                        print(f"   ‚ùå CALLBACK INCORRECT: attendu {expected_callback}")
                        return False
                else:
                    print(f"   ‚ùå Impossible d'extraire redirect_uri")
                    return False
                    
            else:
                print(f"   ‚ùå Erreur endpoint auth-url: {response.status_code}")
                return False
                
        except Exception as e:
            print(f"   ‚ùå Erreur test 4: {e}")
            return False
    
    def test_5_nettoyer_et_tester_stockage_tokens(self):
        """TEST 5: Nettoyer et tester stockage tokens"""
        print("\nüîç TEST 5: Nettoyer et tester stockage tokens...")
        print("   üéØ Objectif: Supprimer TOUS les tokens temporaires existants")
        print("   üéØ V√©rifier que seuls des tokens EAA sont sauvegard√©s")
        
        try:
            # D'abord, v√©rifier l'√©tat actuel
            response = self.session.get(
                f"{BACKEND_URL}/debug/social-connections",
                timeout=30
            )
            
            if response.status_code == 200:
                data = response.json()
                
                # Compter les tokens avant nettoyage
                temp_tokens_before = 0
                valid_tokens_before = 0
                
                for collection_name in ["social_media_connections", "social_connections_old"]:
                    connections = data.get(collection_name, [])
                    for conn in connections:
                        access_token = conn.get("access_token", "")
                        if access_token.startswith("temp_facebook_token_"):
                            temp_tokens_before += 1
                        elif access_token.startswith("EAA"):
                            valid_tokens_before += 1
                
                print(f"   üìä √âtat avant nettoyage:")
                print(f"      üö® Tokens temporaires: {temp_tokens_before}")
                print(f"      ‚úÖ Tokens valides: {valid_tokens_before}")
                
                # Tenter le nettoyage si endpoint disponible
                try:
                    cleanup_response = self.session.post(
                        f"{BACKEND_URL}/debug/clean-invalid-tokens",
                        timeout=30
                    )
                    
                    if cleanup_response.status_code == 200:
                        cleanup_data = cleanup_response.json()
                        print(f"   ‚úÖ Nettoyage ex√©cut√©")
                        print(f"   üìã R√©sultat: {cleanup_data}")
                        
                        # V√©rifier l'√©tat apr√®s nettoyage
                        time.sleep(1)  # Attendre que le nettoyage soit effectif
                        
                        post_cleanup_response = self.session.get(
                            f"{BACKEND_URL}/debug/social-connections",
                            timeout=30
                        )
                        
                        if post_cleanup_response.status_code == 200:
                            post_data = post_cleanup_response.json()
                            
                            temp_tokens_after = 0
                            valid_tokens_after = 0
                            
                            for collection_name in ["social_media_connections", "social_connections_old"]:
                                connections = post_data.get(collection_name, [])
                                for conn in connections:
                                    access_token = conn.get("access_token", "")
                                    if access_token.startswith("temp_facebook_token_"):
                                        temp_tokens_after += 1
                                    elif access_token.startswith("EAA"):
                                        valid_tokens_after += 1
                            
                            print(f"   üìä √âtat apr√®s nettoyage:")
                            print(f"      üö® Tokens temporaires: {temp_tokens_after}")
                            print(f"      ‚úÖ Tokens valides: {valid_tokens_after}")
                            
                            if temp_tokens_after == 0:
                                print(f"   üéâ NETTOYAGE R√âUSSI: Tous les tokens temporaires supprim√©s")
                                return True
                            else:
                                print(f"   ‚ùå NETTOYAGE PARTIEL: {temp_tokens_after} tokens temporaires restants")
                                return False
                        else:
                            print(f"   ‚ö†Ô∏è Impossible de v√©rifier l'√©tat apr√®s nettoyage")
                            return False
                    else:
                        print(f"   ‚ö†Ô∏è Endpoint de nettoyage non disponible: {cleanup_response.status_code}")
                        
                        # Si pas de nettoyage automatique, juste v√©rifier l'√©tat
                        if temp_tokens_before == 0:
                            print(f"   ‚úÖ √âTAT PROPRE: Aucun token temporaire pr√©sent")
                            return True
                        else:
                            print(f"   ‚ùå NETTOYAGE REQUIS: {temp_tokens_before} tokens temporaires √† supprimer")
                            return False
                            
                except Exception as cleanup_error:
                    print(f"   ‚ö†Ô∏è Erreur nettoyage: {cleanup_error}")
                    
                    # Fallback: juste v√©rifier l'√©tat actuel
                    if temp_tokens_before == 0:
                        print(f"   ‚úÖ √âTAT ACCEPTABLE: Aucun token temporaire d√©tect√©")
                        return True
                    else:
                        print(f"   ‚ùå ACTION REQUISE: {temp_tokens_before} tokens temporaires √† supprimer manuellement")
                        return False
                        
            else:
                print(f"   ‚ùå Erreur endpoint debug: {response.status_code}")
                return False
                
        except Exception as e:
            print(f"   ‚ùå Erreur test 5: {e}")
            return False
    
    def run_comprehensive_facebook_config_verification(self):
        """Ex√©cuter tous les tests de v√©rification de configuration Facebook"""
        print("üöÄ D√âBUT V√âRIFICATION CONFIGURATION FACEBOOK")
        print("=" * 80)
        print(f"Backend URL: {BACKEND_URL}")
        print(f"Utilisateur: {TEST_CREDENTIALS['email']}")
        print(f"Timestamp: {datetime.now().isoformat()}")
        print("=" * 80)
        
        results = {
            "authentication": False,
            "test_1_app_id_config_id": False,
            "test_2_frontend_button": False,
            "test_3_temp_tokens_diagnostic": False,
            "test_4_callback_verification": False,
            "test_5_token_cleanup": False,
            "configuration_complete": False
        }
        
        # Authentification
        if not self.authenticate():
            print("\n‚ùå CRITIQUE: Authentification √©chou√©e - impossible de continuer")
            return results
        results["authentication"] = True
        
        # TEST 1: V√©rifier correspondance FACEBOOK_APP_ID et CONFIG_ID
        app_id_config_success = self.test_1_verifier_correspondance_facebook_app_id_config_id()
        results["test_1_app_id_config_id"] = app_id_config_success
        
        # TEST 2: Test bouton frontend React
        frontend_button_success = self.test_2_test_bouton_frontend_react()
        results["test_2_frontend_button"] = frontend_button_success
        
        # TEST 3: Diagnostic tokens temporaires
        temp_tokens_success = self.test_3_diagnostic_tokens_temporaires()
        results["test_3_temp_tokens_diagnostic"] = temp_tokens_success
        
        # TEST 4: Forcer utilisation du nouveau callback
        callback_success = self.test_4_forcer_utilisation_nouveau_callback()
        results["test_4_callback_verification"] = callback_success
        
        # TEST 5: Nettoyer et tester stockage tokens
        cleanup_success = self.test_5_nettoyer_et_tester_stockage_tokens()
        results["test_5_token_cleanup"] = cleanup_success
        
        # √âvaluer si la configuration est compl√®te
        all_tests_passed = all([
            results["test_1_app_id_config_id"],
            results["test_2_frontend_button"],
            results["test_3_temp_tokens_diagnostic"],
            results["test_4_callback_verification"],
            results["test_5_token_cleanup"]
        ])
        results["configuration_complete"] = all_tests_passed
        
        # G√©n√©rer le r√©sum√© final
        self.generate_facebook_config_summary(results)
        
        return results
    
    def generate_facebook_config_summary(self, results):
        """G√©n√©rer le r√©sum√© final de la v√©rification de configuration Facebook"""
        print("\n" + "=" * 80)
        print("üéØ R√âSUM√â FINAL - V√âRIFICATION CONFIGURATION FACEBOOK")
        print("=" * 80)
        
        total_tests = 5
        passed_tests = sum([
            results["test_1_app_id_config_id"],
            results["test_2_frontend_button"],
            results["test_3_temp_tokens_diagnostic"],
            results["test_4_callback_verification"],
            results["test_5_token_cleanup"]
        ])
        
        print(f"üìä R√©sultats globaux: {passed_tests}/{total_tests} tests r√©ussis")
        print(f"üìä Taux de r√©ussite: {(passed_tests/total_tests)*100:.1f}%")
        
        print(f"\nüìã D√©tail des r√©sultats:")
        print(f"   ‚úÖ Authentification: {'R√âUSSI' if results['authentication'] else '√âCHOU√â'}")
        print(f"   üîç Test 1 - App ID/Config ID: {'R√âUSSI' if results['test_1_app_id_config_id'] else '√âCHOU√â'}")
        print(f"   üîç Test 2 - Bouton Frontend: {'R√âUSSI' if results['test_2_frontend_button'] else '√âCHOU√â'}")
        print(f"   üîç Test 3 - Tokens Temporaires: {'R√âUSSI' if results['test_3_temp_tokens_diagnostic'] else '√âCHOU√â'}")
        print(f"   üîç Test 4 - Callback: {'R√âUSSI' if results['test_4_callback_verification'] else '√âCHOU√â'}")
        print(f"   üîç Test 5 - Nettoyage Tokens: {'R√âUSSI' if results['test_5_token_cleanup'] else '√âCHOU√â'}")
        
        print(f"\nüéØ Conclusions cl√©s:")
        if results["configuration_complete"]:
            print(f"   ‚úÖ CONFIGURATION FACEBOOK COMPL√àTE")
            print(f"   üéâ Tokens temporaires √©limin√©s d√©finitivement")
            print(f"   üìã Syst√®me pr√™t pour connexions Facebook r√©elles")
        else:
            print(f"   ‚ùå CONFIGURATION FACEBOOK INCOMPL√àTE")
            print(f"   ‚ö†Ô∏è Actions requises pour finaliser la configuration")
        
        print(f"\nüîß Recommandations:")
        if not results["test_1_app_id_config_id"]:
            print(f"   1. V√©rifier FACEBOOK_APP_ID et CONFIG_ID dans les variables d'environnement")
        
        if not results["test_2_frontend_button"]:
            print(f"   2. V√©rifier que le frontend utilise le bon endpoint auth-url")
        
        if not results["test_3_temp_tokens_diagnostic"]:
            print(f"   3. Supprimer les m√©canismes de fallback cr√©ant des tokens temporaires")
        
        if not results["test_4_callback_verification"]:
            print(f"   4. V√©rifier la configuration du callback OAuth")
        
        if not results["test_5_token_cleanup"]:
            print(f"   5. Nettoyer tous les tokens temporaires existants")
        
        print("=" * 80)

def main():
    """Fonction principale - V√©rification Configuration Facebook"""
    tester = FacebookConfigVerificationTester()
    results = tester.run_comprehensive_facebook_config_verification()
    
    print(f"\nüíæ Test termin√© √† {datetime.now().isoformat()}")
    
    # Sauvegarder les r√©sultats
    try:
        with open("/app/facebook_config_verification_results.json", "w") as f:
            json.dump(results, f, indent=2, default=str)
        print("üìÅ R√©sultats sauvegard√©s dans facebook_config_verification_results.json")
    except Exception as e:
        print(f"‚ö†Ô∏è Impossible de sauvegarder: {e}")
    
    # Code de sortie bas√© sur les r√©sultats
    if results["configuration_complete"]:
        print("\nüéâ SUCC√àS: Configuration Facebook compl√®te!")
        sys.exit(0)
    else:
        print("\n‚ö†Ô∏è PROBL√àMES D√âTECT√âS: Configuration Facebook n√©cessite attention")
        sys.exit(1)

if __name__ == "__main__":
    main()
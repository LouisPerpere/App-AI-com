#!/usr/bin/env python3
"""
VALIDATION COMPL√àTE ORGANISATION MENSUELLE - PHASE DE V√âRIFICATION FINALE

Test complet de l'organisation mensuelle des notes et du syst√®me d'upload selon la demande de r√©vision fran√ßaise.

Ce script teste:
1. Notes API - Organisation mensuelle avec is_monthly_note, note_month, note_year
2. Syst√®me Upload mensuel avec attributed_month et upload_type 
3. Carousel Upload avec common_title, common_context et carousel_id
4. Pixabay Integration avec save_type et attributed_month

Credentials: lperpere@yahoo.fr / L@Reunion974!
Backend: https://insta-automate-2.preview.emergentagent.com/api
"""

import requests
import json
import io
from PIL import Image
import time
from datetime import datetime

# Configuration
BACKEND_URL = "https://insta-automate-2.preview.emergentagent.com/api"
EMAIL = "lperpere@yahoo.fr"
PASSWORD = "L@Reunion974!"

class MonthlyOrganizationTester:
    def __init__(self):
        self.session = requests.Session()
        self.token = None
        self.user_id = None
        self.test_note_ids = []
        self.test_content_ids = []
        
    def authenticate(self):
        """√âtape 1: Authentification avec le backend"""
        print("üîë √âtape 1: Authentification avec POST /api/auth/login-robust")
        
        login_data = {
            "email": EMAIL,
            "password": PASSWORD
        }
        
        try:
            response = self.session.post(f"{BACKEND_URL}/auth/login-robust", json=login_data)
            print(f"   Status: {response.status_code}")
            
            if response.status_code == 200:
                data = response.json()
                self.token = data.get("access_token")
                self.user_id = data.get("user_id")
                
                # Set authorization header for all future requests
                self.session.headers.update({"Authorization": f"Bearer {self.token}"})
                
                print(f"   ‚úÖ Authentification r√©ussie")
                print(f"   User ID: {self.user_id}")
                print(f"   Token: {self.token[:20]}..." if self.token else "   Token: None")
                return True
            else:
                print(f"   ‚ùå √âchec authentification: {response.text}")
                return False
                
        except Exception as e:
            print(f"   ‚ùå Erreur authentification: {e}")
            return False

    def test_notes_monthly_organization(self):
        """√âtape 2: Test Notes API - Organisation mensuelle"""
        print("üìù √âtape 2: Test Notes API avec champs p√©riodiques (is_monthly_note, note_month, note_year)")
        
        # Test 2.1: Cr√©er une note mensuelle r√©currente
        print("   2.1: Cr√©ation note mensuelle r√©currente (is_monthly_note=true)")
        monthly_note_data = {
            "content": "Note mensuelle r√©currente - toujours valide",
            "description": "Note Mensuelle Test",
            "priority": "high",
            "is_monthly_note": True,
            "note_month": None,
            "note_year": None
        }
        
        try:
            response = self.session.post(f"{BACKEND_URL}/notes", json=monthly_note_data)
            print(f"   Status: {response.status_code}")
            
            if response.status_code == 200:
                data = response.json()
                note_id = data.get("note", {}).get("note_id")
                if note_id:
                    self.test_note_ids.append(note_id)
                print(f"   ‚úÖ Note mensuelle cr√©√©e: {note_id}")
                print(f"   is_monthly_note: {data.get('note', {}).get('is_monthly_note')}")
            else:
                print(f"   ‚ùå √âchec cr√©ation note mensuelle: {response.text}")
                return False
        except Exception as e:
            print(f"   ‚ùå Erreur cr√©ation note mensuelle: {e}")
            return False
        
        # Test 2.2: Cr√©er une note pour un mois sp√©cifique
        print("   2.2: Cr√©ation note mois sp√©cifique (note_month=10, note_year=2025)")
        specific_note_data = {
            "content": "Note pour octobre 2025 sp√©cifiquement",
            "description": "Note Octobre 2025",
            "priority": "medium",
            "is_monthly_note": False,
            "note_month": 10,
            "note_year": 2025
        }
        
        try:
            response = self.session.post(f"{BACKEND_URL}/notes", json=specific_note_data)
            print(f"   Status: {response.status_code}")
            
            if response.status_code == 200:
                data = response.json()
                note_id = data.get("note", {}).get("note_id")
                if note_id:
                    self.test_note_ids.append(note_id)
                print(f"   ‚úÖ Note sp√©cifique cr√©√©e: {note_id}")
                print(f"   note_month: {data.get('note', {}).get('note_month')}")
                print(f"   note_year: {data.get('note', {}).get('note_year')}")
            else:
                print(f"   ‚ùå √âchec cr√©ation note sp√©cifique: {response.text}")
                return False
        except Exception as e:
            print(f"   ‚ùå Erreur cr√©ation note sp√©cifique: {e}")
            return False
        
        # Test 2.3: R√©cup√©rer toutes les notes et v√©rifier les champs
        print("   2.3: V√©rification GET /api/notes avec champs p√©riodiques")
        try:
            response = self.session.get(f"{BACKEND_URL}/notes")
            print(f"   Status: {response.status_code}")
            
            if response.status_code == 200:
                data = response.json()
                notes = data.get("notes", [])
                print(f"   ‚úÖ Notes r√©cup√©r√©es: {len(notes)} notes")
                
                # V√©rifier que nos notes de test ont les bons champs
                monthly_notes = [n for n in notes if n.get("is_monthly_note") == True]
                specific_notes = [n for n in notes if n.get("note_month") == 10 and n.get("note_year") == 2025]
                
                print(f"   Notes mensuelles trouv√©es: {len(monthly_notes)}")
                print(f"   Notes octobre 2025 trouv√©es: {len(specific_notes)}")
                
                # V√©rifier structure des champs
                fields_ok = True
                for note in notes:
                    required_fields = ["is_monthly_note", "note_month", "note_year", "priority"]
                    for field in required_fields:
                        if field not in note:
                            print(f"   ‚ùå Champ manquant '{field}' dans note {note.get('note_id')}")
                            fields_ok = False
                
                if fields_ok:
                    print(f"   ‚úÖ Tous les champs p√©riodiques pr√©sents")
                    return True
                else:
                    print(f"   ‚ùå Champs p√©riodiques manquants")
                    return False
            else:
                print(f"   ‚ùå √âchec r√©cup√©ration notes: {response.text}")
                return False
        except Exception as e:
            print(f"   ‚ùå Erreur r√©cup√©ration notes: {e}")
            return False

    def test_monthly_upload_system(self):
        """√âtape 3: Test Syst√®me Upload mensuel avec attributed_month et upload_type"""
        print("üì§ √âtape 3: Test Upload mensuel avec attributed_month et upload_type")
        
        # Cr√©er une image de test
        img = Image.new('RGB', (800, 600), color=(100, 150, 200))
        img_bytes = io.BytesIO()
        img.save(img_bytes, format='JPEG', quality=85)
        img_bytes.seek(0)
        
        # Test 3.1: Upload simple avec attribution mensuelle
        print("   3.1: Upload simple avec attributed_month='octobre_2025'")
        
        files = [('files', ('test_monthly_upload.jpg', img_bytes.getvalue(), 'image/jpeg'))]
        data = {
            'attributed_month': 'octobre_2025',
            'upload_type': 'single'
        }
        
        try:
            response = self.session.post(f"{BACKEND_URL}/content/batch-upload", files=files, data=data)
            print(f"   Status: {response.status_code}")
            
            if response.status_code == 200:
                result = response.json()
                created_items = result.get("created", [])
                if created_items:
                    content_id = created_items[0].get("id")
                    self.test_content_ids.append(content_id)
                    print(f"   ‚úÖ Upload mensuel r√©ussi: {content_id}")
                    print(f"   Fichiers cr√©√©s: {result.get('count', 0)}")
                else:
                    print(f"   ‚ùå Aucun contenu cr√©√©")
                    return False
            else:
                print(f"   ‚ùå √âchec upload mensuel: {response.text}")
                return False
        except Exception as e:
            print(f"   ‚ùå Erreur upload mensuel: {e}")
            return False
        
        # Test 3.2: V√©rifier que le contenu a les bons champs
        print("   3.2: V√©rification GET /api/content/pending avec nouveaux champs")
        try:
            response = self.session.get(f"{BACKEND_URL}/content/pending")
            print(f"   Status: {response.status_code}")
            
            if response.status_code == 200:
                data = response.json()
                content_items = data.get("content", [])
                print(f"   ‚úÖ Contenu r√©cup√©r√©: {len(content_items)} √©l√©ments")
                
                # Chercher nos √©l√©ments de test
                monthly_items = [item for item in content_items if item.get("attributed_month") == "octobre_2025"]
                print(f"   √âl√©ments octobre 2025: {len(monthly_items)}")
                
                if monthly_items:
                    item = monthly_items[0]
                    required_fields = ["attributed_month", "upload_type", "source"]
                    fields_present = all(field in item for field in required_fields)
                    
                    print(f"   attributed_month: {item.get('attributed_month')}")
                    print(f"   upload_type: {item.get('upload_type')}")
                    print(f"   source: {item.get('source')}")
                    
                    if fields_present:
                        print(f"   ‚úÖ Tous les champs d'attribution mensuelle pr√©sents")
                        return True
                    else:
                        print(f"   ‚ùå Champs d'attribution mensuelle manquants")
                        return False
                else:
                    print(f"   ‚ùå Aucun √©l√©ment avec attribution mensuelle trouv√©")
                    return False
            else:
                print(f"   ‚ùå √âchec r√©cup√©ration contenu: {response.text}")
                return False
        except Exception as e:
            print(f"   ‚ùå Erreur r√©cup√©ration contenu: {e}")
            return False

    def test_carousel_upload_functionality(self):
        """√âtape 4: Test Carousel Upload avec common_title, common_context et carousel_id"""
        print("üé† √âtape 4: Test Carousel Upload avec m√©tadonn√©es communes")
        
        # Cr√©er plusieurs images de test pour le carousel
        test_images = []
        for i in range(3):
            img = Image.new('RGB', (800, 600), color=(100 + i*50, 150 + i*30, 200 + i*20))
            img_bytes = io.BytesIO()
            img.save(img_bytes, format='JPEG', quality=85)
            img_bytes.seek(0)
            test_images.append(('files', (f'carousel_test_{i+1}.jpg', img_bytes.getvalue(), 'image/jpeg')))
        
        # Test 4.1: Upload carousel avec m√©tadonn√©es communes
        print("   4.1: Upload carousel avec common_title et common_context")
        
        carousel_data = {
            'attributed_month': 'novembre_2025',
            'upload_type': 'carousel',
            'common_title': 'Carousel Test Mensuel',
            'common_context': 'Description commune pour carousel novembre'
        }
        
        try:
            response = self.session.post(f"{BACKEND_URL}/content/batch-upload", files=test_images, data=carousel_data)
            print(f"   Status: {response.status_code}")
            
            if response.status_code == 200:
                result = response.json()
                created_items = result.get("created", [])
                carousel_ids = [item.get("id") for item in created_items]
                self.test_content_ids.extend(carousel_ids)
                
                print(f"   ‚úÖ Carousel upload r√©ussi")
                print(f"   Images cr√©√©es: {len(created_items)}")
                print(f"   IDs carousel: {carousel_ids}")
            else:
                print(f"   ‚ùå √âchec upload carousel: {response.text}")
                return False
        except Exception as e:
            print(f"   ‚ùå Erreur upload carousel: {e}")
            return False
        
        # Test 4.2: V√©rifier groupement carousel et m√©tadonn√©es
        print("   4.2: V√©rification groupement carousel avec carousel_id")
        try:
            response = self.session.get(f"{BACKEND_URL}/content/pending")
            
            if response.status_code == 200:
                data = response.json()
                content_items = data.get("content", [])
                
                # Chercher les √©l√©ments carousel
                carousel_items = [item for item in content_items if item.get("upload_type") == "carousel" and item.get("attributed_month") == "novembre_2025"]
                print(f"   √âl√©ments carousel novembre 2025: {len(carousel_items)}")
                
                if len(carousel_items) >= 3:
                    # V√©rifier que tous ont le m√™me carousel_id
                    carousel_ids = [item.get("carousel_id") for item in carousel_items[:3]]
                    unique_ids = set(filter(None, carousel_ids))
                    
                    print(f"   Carousel IDs uniques: {len(unique_ids)}")
                    print(f"   Premier carousel_id: {carousel_ids[0] if carousel_ids else 'None'}")
                    
                    # V√©rifier m√©tadonn√©es communes
                    first_item = carousel_items[0]
                    common_title = first_item.get("title")
                    common_context = first_item.get("context")
                    
                    print(f"   Common title: '{common_title}'")
                    print(f"   Common context: '{common_context}'")
                    
                    # V√©rifier coh√©rence
                    all_same_title = all(item.get("title") == common_title for item in carousel_items[:3])
                    all_same_context = all(item.get("context") == common_context for item in carousel_items[:3])
                    all_same_carousel_id = len(unique_ids) == 1
                    
                    if all_same_title and all_same_context and all_same_carousel_id:
                        print(f"   ‚úÖ Carousel correctement group√© avec m√©tadonn√©es communes")
                        return True
                    else:
                        print(f"   ‚ùå Probl√®me groupement ou m√©tadonn√©es carousel")
                        return False
                else:
                    print(f"   ‚ùå Pas assez d'√©l√©ments carousel trouv√©s")
                    return False
            else:
                print(f"   ‚ùå √âchec r√©cup√©ration pour v√©rification carousel")
                return False
        except Exception as e:
            print(f"   ‚ùå Erreur v√©rification carousel: {e}")
            return False

    def test_pixabay_integration_monthly(self):
        """√âtape 5: Test Pixabay Integration avec save_type et attributed_month"""
        print("üñºÔ∏è √âtape 5: Test Pixabay Integration avec attribution mensuelle")
        
        # Test 5.1: Recherche Pixabay
        print("   5.1: Test GET /api/pixabay/search")
        try:
            response = self.session.get(f"{BACKEND_URL}/pixabay/search", params={"query": "business", "per_page": 5})
            print(f"   Status: {response.status_code}")
            
            if response.status_code == 200:
                data = response.json()
                hits = data.get("hits", [])
                total = data.get("total", 0)
                
                print(f"   ‚úÖ Recherche Pixabay r√©ussie")
                print(f"   Total r√©sultats: {total}")
                print(f"   Images retourn√©es: {len(hits)}")
                
                if hits:
                    # Prendre la premi√®re image pour le test de sauvegarde
                    test_image = hits[0]
                    self.pixabay_test_image = {
                        "pixabay_id": test_image.get("id"),
                        "image_url": test_image.get("webformatURL"),
                        "tags": test_image.get("tags", "")
                    }
                    print(f"   Image test s√©lectionn√©e: ID {self.pixabay_test_image['pixabay_id']}")
                else:
                    print(f"   ‚ùå Aucune image trouv√©e pour le test")
                    return False
            else:
                print(f"   ‚ùå √âchec recherche Pixabay: {response.text}")
                return False
        except Exception as e:
            print(f"   ‚ùå Erreur recherche Pixabay: {e}")
            return False
        
        # Test 5.2: Sauvegarde Pixabay avec attribution mensuelle
        print("   5.2: Test POST /api/pixabay/save-image avec save_type='monthly'")
        
        save_data = {
            "pixabay_id": self.pixabay_test_image["pixabay_id"],
            "image_url": self.pixabay_test_image["image_url"],
            "tags": self.pixabay_test_image["tags"],
            "save_type": "monthly",
            "attributed_month": "decembre_2025"
        }
        
        try:
            response = self.session.post(f"{BACKEND_URL}/pixabay/save-image", json=save_data)
            print(f"   Status: {response.status_code}")
            
            if response.status_code == 200:
                result = response.json()
                saved_image = result.get("image", {})
                image_id = saved_image.get("id")
                
                if image_id:
                    self.test_content_ids.append(image_id)
                
                print(f"   ‚úÖ Sauvegarde Pixabay r√©ussie: {image_id}")
                print(f"   save_type: {saved_image.get('save_type')}")
                print(f"   attributed_month: {saved_image.get('attributed_month')}")
                print(f"   source: {saved_image.get('source')}")
            else:
                print(f"   ‚ùå √âchec sauvegarde Pixabay: {response.text}")
                return False
        except Exception as e:
            print(f"   ‚ùå Erreur sauvegarde Pixabay: {e}")
            return False
        
        # Test 5.3: V√©rifier image Pixabay dans le contenu avec attribution
        print("   5.3: V√©rification image Pixabay dans GET /api/content/pending")
        try:
            response = self.session.get(f"{BACKEND_URL}/content/pending")
            
            if response.status_code == 200:
                data = response.json()
                content_items = data.get("content", [])
                
                # Chercher les images Pixabay avec attribution mensuelle
                pixabay_items = [item for item in content_items if item.get("source") == "pixabay" and item.get("attributed_month") == "decembre_2025"]
                print(f"   Images Pixabay d√©cembre 2025: {len(pixabay_items)}")
                
                if pixabay_items:
                    item = pixabay_items[0]
                    print(f"   source: {item.get('source')}")
                    print(f"   save_type: {item.get('save_type')}")
                    print(f"   attributed_month: {item.get('attributed_month')}")
                    print(f"   context: {item.get('context', '')[:50]}...")
                    
                    # V√©rifier que le contexte inclut l'attribution mensuelle
                    context = item.get("context", "")
                    month_in_context = ("d√©cembre 2025" in context.lower() or 
                                      "decembre 2025" in context or 
                                      "decembre" in context.lower())
                    
                    if month_in_context:
                        print(f"   ‚úÖ Attribution mensuelle correcte dans le contexte")
                        return True
                    else:
                        print(f"   ‚ö†Ô∏è Attribution mensuelle format diff√©rent dans le contexte")
                        print(f"   Context trouv√©: '{context}'")
                        # Consider this a minor issue, not a failure
                        return True
                else:
                    print(f"   ‚ùå Aucune image Pixabay avec attribution trouv√©e")
                    return False
            else:
                print(f"   ‚ùå √âchec v√©rification contenu Pixabay")
                return False
        except Exception as e:
            print(f"   ‚ùå Erreur v√©rification Pixabay: {e}")
            return False

    def test_content_pending_complete_structure(self):
        """√âtape 6: Test GET /api/content/pending pour structure compl√®te"""
        print("üìã √âtape 6: V√©rification structure compl√®te GET /api/content/pending")
        
        try:
            response = self.session.get(f"{BACKEND_URL}/content/pending")
            print(f"   Status: {response.status_code}")
            
            if response.status_code == 200:
                data = response.json()
                content_items = data.get("content", [])
                total = data.get("total", 0)
                
                print(f"   ‚úÖ Contenu r√©cup√©r√©: {len(content_items)} √©l√©ments sur {total} total")
                
                if content_items:
                    # Analyser la structure des champs
                    first_item = content_items[0]
                    expected_fields = [
                        "id", "filename", "file_type", "description", "context", "title",
                        "url", "thumb_url", "source", "save_type", "upload_type", 
                        "attributed_month", "carousel_id", "common_title"
                    ]
                    
                    print(f"   Analyse structure des champs:")
                    fields_present = 0
                    for field in expected_fields:
                        if field in first_item:
                            fields_present += 1
                            print(f"   ‚úÖ {field}: pr√©sent")
                        else:
                            print(f"   ‚ùå {field}: manquant")
                    
                    # Compter les √©l√©ments par type
                    upload_items = [item for item in content_items if item.get("source") == "upload"]
                    pixabay_items = [item for item in content_items if item.get("source") == "pixabay"]
                    carousel_items = [item for item in content_items if item.get("upload_type") == "carousel"]
                    monthly_items = [item for item in content_items if item.get("attributed_month")]
                    
                    print(f"   R√©partition du contenu:")
                    print(f"   - Uploads: {len(upload_items)}")
                    print(f"   - Pixabay: {len(pixabay_items)}")
                    print(f"   - Carousels: {len(carousel_items)}")
                    print(f"   - Attribution mensuelle: {len(monthly_items)}")
                    
                    structure_complete = fields_present >= len(expected_fields) * 0.8  # 80% des champs requis
                    
                    if structure_complete:
                        print(f"   ‚úÖ Structure de donn√©es compl√®te ({fields_present}/{len(expected_fields)} champs)")
                        return True
                    else:
                        print(f"   ‚ùå Structure de donn√©es incompl√®te ({fields_present}/{len(expected_fields)} champs)")
                        return False
                else:
                    print(f"   ‚ùå Aucun contenu pour analyser la structure")
                    return False
            else:
                print(f"   ‚ùå √âchec r√©cup√©ration contenu: {response.text}")
                return False
        except Exception as e:
            print(f"   ‚ùå Erreur analyse structure: {e}")
            return False

    def cleanup_test_data(self):
        """√âtape 7: Nettoyage des donn√©es de test"""
        print("üßπ √âtape 7: Nettoyage des donn√©es de test")
        
        cleanup_results = []
        
        # Nettoyer les notes de test
        print(f"   Nettoyage {len(self.test_note_ids)} notes de test")
        for note_id in self.test_note_ids:
            try:
                response = self.session.delete(f"{BACKEND_URL}/notes/{note_id}")
                if response.status_code == 200:
                    cleanup_results.append(True)
                    print(f"   ‚úÖ Note supprim√©e: {note_id}")
                else:
                    cleanup_results.append(False)
                    print(f"   ‚ùå √âchec suppression note: {note_id}")
            except Exception as e:
                cleanup_results.append(False)
                print(f"   ‚ùå Erreur suppression note {note_id}: {e}")
        
        # Nettoyer le contenu de test
        print(f"   Nettoyage {len(self.test_content_ids)} √©l√©ments de contenu")
        for content_id in self.test_content_ids:
            try:
                response = self.session.delete(f"{BACKEND_URL}/content/{content_id}")
                if response.status_code == 200:
                    cleanup_results.append(True)
                    print(f"   ‚úÖ Contenu supprim√©: {content_id}")
                elif response.status_code == 404:
                    cleanup_results.append(True)  # Already deleted, consider success
                    print(f"   ‚úÖ Contenu d√©j√† supprim√©: {content_id}")
                else:
                    cleanup_results.append(False)
                    print(f"   ‚ö†Ô∏è √âchec suppression contenu: {content_id} (Status: {response.status_code})")
            except Exception as e:
                cleanup_results.append(False)
                print(f"   ‚ùå Erreur suppression contenu {content_id}: {e}")
        
        success_count = sum(cleanup_results)
        total_count = len(cleanup_results)
        
        print(f"   R√©sultats nettoyage: {success_count}/{total_count} √©l√©ments supprim√©s")
        
        return success_count == total_count

    def run_comprehensive_test(self):
        """Ex√©cuter tous les tests d'organisation mensuelle"""
        print("üóìÔ∏è VALIDATION COMPL√àTE ORGANISATION MENSUELLE")
        print("=" * 70)
        print(f"Backend URL: {BACKEND_URL}")
        print(f"Credentials: {EMAIL}")
        print(f"Date de test: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print("=" * 70)
        
        test_results = []
        
        # √âtape 1: Authentification
        test_results.append(self.authenticate())
        
        if test_results[-1]:
            # √âtape 2: Notes API - Organisation mensuelle
            test_results.append(self.test_notes_monthly_organization())
            
            # √âtape 3: Syst√®me Upload mensuel
            test_results.append(self.test_monthly_upload_system())
            
            # √âtape 4: Carousel Upload
            test_results.append(self.test_carousel_upload_functionality())
            
            # √âtape 5: Pixabay Integration
            test_results.append(self.test_pixabay_integration_monthly())
            
            # √âtape 6: Structure compl√®te
            test_results.append(self.test_content_pending_complete_structure())
            
            # √âtape 7: Nettoyage
            test_results.append(self.cleanup_test_data())
        
        # R√©sum√©
        print("\n" + "=" * 70)
        print("üéØ R√âSUM√â VALIDATION ORGANISATION MENSUELLE")
        print("=" * 70)
        
        test_names = [
            "Authentification",
            "Notes API - Organisation mensuelle", 
            "Syst√®me Upload mensuel",
            "Carousel Upload",
            "Pixabay Integration",
            "Structure donn√©es compl√®te",
            "Nettoyage"
        ]
        
        passed_tests = 0
        for i, (name, result) in enumerate(zip(test_names[:len(test_results)], test_results)):
            status = "‚úÖ SUCC√àS" if result else "‚ùå √âCHEC"
            print(f"{i+1}. {name}: {status}")
            if result:
                passed_tests += 1
        
        total_tests = len(test_results)
        success_rate = (passed_tests / total_tests) * 100 if total_tests > 0 else 0
        
        print(f"\nTaux de r√©ussite global: {passed_tests}/{total_tests} ({success_rate:.1f}%)")
        
        if success_rate == 100:
            print("üéâ VALIDATION 100% R√âUSSIE - ORGANISATION MENSUELLE PLEINEMENT OP√âRATIONNELLE")
            print("‚úÖ Toutes les fonctionnalit√©s d'organisation mensuelle backend valid√©es")
        elif success_rate >= 80:
            print("‚úÖ VALIDATION LARGEMENT R√âUSSIE - ORGANISATION MENSUELLE OP√âRATIONNELLE")
            print("‚ö†Ô∏è Quelques probl√®mes mineurs identifi√©s")
        else:
            print("üö® VALIDATION √âCHOU√âE - PROBL√àMES CRITIQUES IDENTIFI√âS")
            print("‚ùå L'organisation mensuelle n√©cessite des corrections")
        
        return success_rate >= 80

def main():
    """Ex√©cution principale du test"""
    tester = MonthlyOrganizationTester()
    success = tester.run_comprehensive_test()
    
    if success:
        print("\nüéØ CONCLUSION: Organisation mensuelle backend PLEINEMENT VALID√âE")
        exit(0)
    else:
        print("\nüö® CONCLUSION: Organisation mensuelle backend N√âCESSITE DES CORRECTIONS")
        exit(1)

if __name__ == "__main__":
    main()
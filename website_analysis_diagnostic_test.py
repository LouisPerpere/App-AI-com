#!/usr/bin/env python3
"""
DIAGNOSTIC MODULE D'ANALYSE DE SITE WEB
Test sp√©cifique pour diagnostiquer le probl√®me "analyse non concluante, v√©rifiez votre site web"

Tests requis selon la review request:
1. Test de connexion utilisateur - lperpere@yahoo.fr / L@Reunion974!
2. Test d'existence de l'endpoint - GET/POST vers /api/website/analyze
3. Test avec URL r√©elle - POST /api/website/analyze avec {"website_url": "https://www.google.com", "force_reanalysis": true}
4. V√©rification cl√©s API - Tester si les cl√©s OpenAI/Emergent sont disponibles et fonctionnelles
5. Test fallback analysis - V√©rifier que le fallback fonctionne si l'API √©choue
6. V√©rification logs - Analyser les logs d'erreur du backend
"""

import requests
import json
import os
import sys
from datetime import datetime

class WebsiteAnalysisDiagnostic:
    def __init__(self):
        # Use production backend URL from frontend/.env
        self.base_url = "https://media-title-fix.preview.emergentagent.com"
        self.api_url = f"{self.base_url}/api"
        self.access_token = None
        self.tests_run = 0
        self.tests_passed = 0
        
        print("üîç DIAGNOSTIC MODULE D'ANALYSE DE SITE WEB")
        print("=" * 60)
        print(f"Backend URL: {self.base_url}")
        print(f"API URL: {self.api_url}")
        print("=" * 60)

    def run_test(self, name, method, endpoint, expected_status, data=None, headers=None):
        """Run a single API test"""
        url = f"{self.api_url}/{endpoint}"
        test_headers = {}
        
        # Add authentication header if we have a token
        if self.access_token:
            test_headers['Authorization'] = f'Bearer {self.access_token}'
        
        # Add custom headers
        if headers:
            test_headers.update(headers)
        
        # Set Content-Type for JSON requests
        if method in ['POST', 'PUT'] and not headers:
            test_headers['Content-Type'] = 'application/json'

        self.tests_run += 1
        print(f"\nüîç Test {self.tests_run}: {name}")
        print(f"   URL: {url}")
        print(f"   Method: {method}")
        if data:
            print(f"   Data: {json.dumps(data, indent=2)}")
        
        try:
            if method == 'GET':
                response = requests.get(url, headers=test_headers, params=data, timeout=30)
            elif method == 'POST':
                response = requests.post(url, json=data, headers=test_headers, timeout=30)
            elif method == 'PUT':
                response = requests.put(url, json=data, headers=test_headers, timeout=30)
            elif method == 'DELETE':
                response = requests.delete(url, headers=test_headers, timeout=30)

            success = response.status_code == expected_status
            
            print(f"   Status Code: {response.status_code} (Expected: {expected_status})")
            
            if success:
                self.tests_passed += 1
                print(f"‚úÖ PASSED")
                try:
                    response_data = response.json()
                    print(f"   Response Keys: {list(response_data.keys()) if isinstance(response_data, dict) else 'Not a dict'}")
                    
                    # Show relevant response data
                    if isinstance(response_data, dict):
                        if 'message' in response_data:
                            print(f"   Message: {response_data['message']}")
                        if 'status' in response_data:
                            print(f"   Status: {response_data['status']}")
                        if 'insights' in response_data:
                            insights = response_data['insights']
                            print(f"   Insights Count: {len(insights) if isinstance(insights, list) else 'Not a list'}")
                        if 'content_suggestions' in response_data:
                            suggestions = response_data['content_suggestions']
                            print(f"   Suggestions Count: {len(suggestions) if isinstance(suggestions, list) else 'Not a list'}")
                    
                    return True, response_data
                except:
                    return True, response.text
            else:
                print(f"‚ùå FAILED")
                try:
                    error_data = response.json()
                    print(f"   Error Response: {json.dumps(error_data, indent=2)}")
                    return False, error_data
                except:
                    print(f"   Error Text: {response.text}")
                    return False, response.text

        except requests.exceptions.Timeout:
            print(f"‚ùå FAILED - Request timeout (30s)")
            return False, {"error": "timeout"}
        except requests.exceptions.ConnectionError:
            print(f"‚ùå FAILED - Connection error")
            return False, {"error": "connection_error"}
        except Exception as e:
            print(f"‚ùå FAILED - Exception: {str(e)}")
            return False, {"error": str(e)}

    def test_1_user_authentication(self):
        """Test 1: Connexion utilisateur avec lperpere@yahoo.fr / L@Reunion974!"""
        print("\n" + "="*60)
        print("TEST 1: CONNEXION UTILISATEUR")
        print("="*60)
        
        login_data = {
            "email": "lperpere@yahoo.fr",
            "password": "L@Reunion974!"
        }
        
        success, response = self.run_test(
            "User Login (lperpere@yahoo.fr)",
            "POST",
            "auth/login",
            200,
            data=login_data
        )
        
        if success and isinstance(response, dict) and 'access_token' in response:
            self.access_token = response['access_token']
            print(f"   ‚úÖ Access Token obtained: {self.access_token[:20]}...")
            print(f"   ‚úÖ User ID: {response.get('user_id', 'N/A')}")
            return True
        else:
            print(f"   ‚ùå Login failed - cannot proceed with authenticated tests")
            return False

    def test_2_endpoint_existence(self):
        """Test 2: V√©rification de l'existence de l'endpoint /api/website/analyze"""
        print("\n" + "="*60)
        print("TEST 2: EXISTENCE DE L'ENDPOINT")
        print("="*60)
        
        if not self.access_token:
            print("‚ùå Skipping - No access token available")
            return False
        
        # Test GET endpoint (should return 405 Method Not Allowed or 404)
        success_get, response_get = self.run_test(
            "GET /api/website/analyze (Method Check)",
            "GET",
            "website/analyze",
            405  # Method not allowed is acceptable
        )
        
        # If GET returns 404, endpoint might not exist
        if not success_get:
            # Try with different status codes
            success_get_404, response_get_404 = self.run_test(
                "GET /api/website/analyze (Existence Check)",
                "GET", 
                "website/analyze",
                404
            )
            if success_get_404:
                print("   ‚ö†Ô∏è GET endpoint returns 404 - endpoint may not exist")
            else:
                print("   ‚úÖ Endpoint exists (returns error as expected)")
        
        # Test POST endpoint structure (without data first)
        success_post, response_post = self.run_test(
            "POST /api/website/analyze (Structure Check)",
            "POST",
            "website/analyze", 
            400,  # Bad request expected without data
            data={}
        )
        
        if success_post:
            print("   ‚úÖ POST endpoint exists and validates input")
            return True
        else:
            # Try with 422 (validation error)
            success_post_422, response_post_422 = self.run_test(
                "POST /api/website/analyze (Validation Check)",
                "POST",
                "website/analyze",
                422,
                data={}
            )
            return success_post_422

    def test_3_real_url_analysis(self):
        """Test 3: Test avec URL r√©elle - https://www.google.com"""
        print("\n" + "="*60)
        print("TEST 3: ANALYSE URL R√âELLE")
        print("="*60)
        
        if not self.access_token:
            print("‚ùå Skipping - No access token available")
            return False
        
        test_data = {
            "website_url": "https://www.google.com",
            "force_reanalysis": True
        }
        
        success, response = self.run_test(
            "Website Analysis (Google.com)",
            "POST",
            "website/analyze",
            200,
            data=test_data
        )
        
        if success and isinstance(response, dict):
            # Check for expected response fields
            expected_fields = ['message', 'website_url', 'status']
            missing_fields = []
            
            for field in expected_fields:
                if field not in response:
                    missing_fields.append(field)
            
            if missing_fields:
                print(f"   ‚ö†Ô∏è Missing expected fields: {missing_fields}")
            else:
                print(f"   ‚úÖ All expected fields present")
            
            # Check for analysis content
            if 'insights' in response and response['insights']:
                print(f"   ‚úÖ Analysis insights provided")
            else:
                print(f"   ‚ö†Ô∏è No insights in response")
            
            if 'content_suggestions' in response and response['content_suggestions']:
                print(f"   ‚úÖ Content suggestions provided")
            else:
                print(f"   ‚ö†Ô∏è No content suggestions in response")
            
            # Check for "analyse non concluante" message
            message = response.get('message', '').lower()
            if 'non concluante' in message or 'v√©rifiez votre site' in message:
                print(f"   ‚ùå PROBL√àME IDENTIFI√â: Message d'erreur d√©tect√©: {response.get('message')}")
                return False
            else:
                print(f"   ‚úÖ Pas de message d'erreur 'non concluante'")
                return True
        
        return success

    def test_4_api_keys_verification(self):
        """Test 4: V√©rification des cl√©s API OpenAI/Emergent"""
        print("\n" + "="*60)
        print("TEST 4: V√âRIFICATION CL√âS API")
        print("="*60)
        
        # Check backend environment variables
        print("   Checking backend environment configuration...")
        
        # Test with a simple URL to see if API keys work
        if not self.access_token:
            print("‚ùå Skipping - No access token available")
            return False
        
        test_data = {
            "website_url": "https://httpbin.org/get",  # Simple test URL
            "force_reanalysis": True
        }
        
        success, response = self.run_test(
            "API Keys Test (Simple URL)",
            "POST",
            "website/analyze",
            200,
            data=test_data
        )
        
        if success and isinstance(response, dict):
            message = response.get('message', '')
            
            # Check for API key related errors
            if 'api key' in message.lower() or 'openai' in message.lower():
                print(f"   ‚ùå API Key issue detected: {message}")
                return False
            elif 'gpt' in message.lower() or 'analysis completed' in message.lower():
                print(f"   ‚úÖ API keys appear to be working")
                return True
            else:
                print(f"   ‚ö†Ô∏è Unclear API key status from message: {message}")
                return True  # Assume working if no clear error
        
        return success

    def test_5_fallback_analysis(self):
        """Test 5: Test du syst√®me de fallback"""
        print("\n" + "="*60)
        print("TEST 5: SYST√àME DE FALLBACK")
        print("="*60)
        
        if not self.access_token:
            print("‚ùå Skipping - No access token available")
            return False
        
        # Test with an unreachable URL to trigger fallback
        test_data = {
            "website_url": "https://this-domain-does-not-exist-12345.com",
            "force_reanalysis": True
        }
        
        success, response = self.run_test(
            "Fallback Test (Unreachable URL)",
            "POST",
            "website/analyze",
            200,  # Should still return 200 with fallback
            data=test_data
        )
        
        if success and isinstance(response, dict):
            message = response.get('message', '')
            
            # Check if fallback was triggered
            if 'fallback' in message.lower() or 'demo' in message.lower():
                print(f"   ‚úÖ Fallback system activated")
                return True
            elif 'error' in message.lower() or 'failed' in message.lower():
                print(f"   ‚ö†Ô∏è Error returned instead of fallback: {message}")
                return False
            else:
                print(f"   ‚úÖ System handled unreachable URL gracefully")
                return True
        else:
            # Test with 400 status (might return error for invalid URL)
            success_400, response_400 = self.run_test(
                "Fallback Test (Error Handling)",
                "POST",
                "website/analyze",
                400,
                data=test_data
            )
            
            if success_400:
                print(f"   ‚úÖ System properly validates URLs")
                return True
        
        return success

    def test_6_backend_logs_analysis(self):
        """Test 6: Analyse des logs backend (via diagnostic endpoint)"""
        print("\n" + "="*60)
        print("TEST 6: ANALYSE DES LOGS BACKEND")
        print("="*60)
        
        # Test diagnostic endpoint
        success, response = self.run_test(
            "Backend Diagnostic",
            "GET",
            "diag",
            200
        )
        
        if success and isinstance(response, dict):
            print(f"   Database Connected: {response.get('database_connected', 'Unknown')}")
            print(f"   Database Name: {response.get('database_name', 'Unknown')}")
            print(f"   Environment: {response.get('environment', 'Unknown')}")
            
            if response.get('database_connected') == False:
                print(f"   ‚ö†Ô∏è Database connection issue detected")
            else:
                print(f"   ‚úÖ Database connection appears healthy")
        
        # Test health endpoint
        success_health, response_health = self.run_test(
            "Backend Health Check",
            "GET",
            "health",
            200
        )
        
        if success_health:
            print(f"   ‚úÖ Backend health check passed")
        else:
            print(f"   ‚ö†Ô∏è Backend health check failed")
        
        return success and success_health

    def test_7_comprehensive_analysis_flow(self):
        """Test 7: Test complet du flux d'analyse"""
        print("\n" + "="*60)
        print("TEST 7: FLUX D'ANALYSE COMPLET")
        print("="*60)
        
        if not self.access_token:
            print("‚ùå Skipping - No access token available")
            return False
        
        # Test multiple URLs to see pattern
        test_urls = [
            "https://www.google.com",
            "https://www.github.com", 
            "https://www.example.com"
        ]
        
        results = []
        
        for url in test_urls:
            test_data = {
                "website_url": url,
                "force_reanalysis": True
            }
            
            success, response = self.run_test(
                f"Analysis Flow Test ({url})",
                "POST",
                "website/analyze",
                200,
                data=test_data
            )
            
            if success and isinstance(response, dict):
                message = response.get('message', '')
                has_insights = bool(response.get('insights'))
                has_suggestions = bool(response.get('content_suggestions'))
                
                result = {
                    'url': url,
                    'success': True,
                    'message': message,
                    'has_insights': has_insights,
                    'has_suggestions': has_suggestions,
                    'problematic': 'non concluante' in message.lower()
                }
            else:
                result = {
                    'url': url,
                    'success': False,
                    'message': str(response),
                    'has_insights': False,
                    'has_suggestions': False,
                    'problematic': True
                }
            
            results.append(result)
        
        # Analyze results
        successful_analyses = sum(1 for r in results if r['success'] and not r['problematic'])
        total_tests = len(results)
        
        print(f"\n   R√âSULTATS DU FLUX D'ANALYSE:")
        print(f"   Analyses r√©ussies: {successful_analyses}/{total_tests}")
        
        for result in results:
            status = "‚úÖ" if result['success'] and not result['problematic'] else "‚ùå"
            print(f"   {status} {result['url']}: {result['message'][:50]}...")
        
        return successful_analyses > 0

    def run_diagnostic(self):
        """Run complete diagnostic sequence"""
        print("üöÄ D√âMARRAGE DU DIAGNOSTIC COMPLET")
        print("Objectif: Identifier pourquoi le module d'analyse retourne 'analyse non concluante'")
        
        # Run all diagnostic tests
        test_results = []
        
        test_results.append(("Connexion Utilisateur", self.test_1_user_authentication()))
        test_results.append(("Existence Endpoint", self.test_2_endpoint_existence()))
        test_results.append(("Analyse URL R√©elle", self.test_3_real_url_analysis()))
        test_results.append(("V√©rification Cl√©s API", self.test_4_api_keys_verification()))
        test_results.append(("Syst√®me Fallback", self.test_5_fallback_analysis()))
        test_results.append(("Logs Backend", self.test_6_backend_logs_analysis()))
        test_results.append(("Flux Complet", self.test_7_comprehensive_analysis_flow()))
        
        # Print summary
        print("\n" + "="*60)
        print("R√âSUM√â DU DIAGNOSTIC")
        print("="*60)
        
        passed_tests = sum(1 for _, result in test_results if result)
        total_tests = len(test_results)
        
        print(f"Tests r√©ussis: {passed_tests}/{total_tests}")
        print(f"Taux de r√©ussite: {(passed_tests/total_tests)*100:.1f}%")
        
        print("\nD√©tail des r√©sultats:")
        for test_name, result in test_results:
            status = "‚úÖ R√âUSSI" if result else "‚ùå √âCHEC"
            print(f"  {status}: {test_name}")
        
        # Diagnostic conclusion
        print("\n" + "="*60)
        print("CONCLUSION DU DIAGNOSTIC")
        print("="*60)
        
        if passed_tests == total_tests:
            print("‚úÖ DIAGNOSTIC COMPLET: Tous les tests sont r√©ussis")
            print("   Le module d'analyse de site web fonctionne correctement")
            print("   Si l'utilisateur rencontre encore des probl√®mes, v√©rifier:")
            print("   - La configuration frontend")
            print("   - Les param√®tres de requ√™te")
            print("   - La gestion des erreurs c√¥t√© client")
        elif passed_tests >= total_tests * 0.7:
            print("‚ö†Ô∏è DIAGNOSTIC PARTIEL: La plupart des tests r√©ussissent")
            print("   Le backend semble fonctionnel mais quelques probl√®mes d√©tect√©s")
            print("   V√©rifier les tests √©chou√©s pour identifier les probl√®mes sp√©cifiques")
        else:
            print("‚ùå DIAGNOSTIC CRITIQUE: Plusieurs probl√®mes d√©tect√©s")
            print("   Le module d'analyse n√©cessite des corrections importantes")
            print("   Priorit√© aux tests d'authentification et d'endpoint")
        
        return test_results

if __name__ == "__main__":
    diagnostic = WebsiteAnalysisDiagnostic()
    results = diagnostic.run_diagnostic()
    
    # Exit with appropriate code
    passed_tests = sum(1 for _, result in results if result)
    total_tests = len(results)
    
    if passed_tests == total_tests:
        sys.exit(0)  # All tests passed
    elif passed_tests >= total_tests * 0.7:
        sys.exit(1)  # Partial success
    else:
        sys.exit(2)  # Critical issues